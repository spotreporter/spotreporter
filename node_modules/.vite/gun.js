var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};

// .yarn/unplugged/gun-virtual-b4ca5c2314/node_modules/gun/gun.js
var require_gun = __commonJS((exports, module) => {
  (function() {
    function USE(arg, req) {
      return req ? require(arg) : arg.slice ? USE[R(arg)] : function(mod, path) {
        arg(mod = {exports: {}});
        USE[R(path)] = mod.exports;
      };
      function R(p) {
        return p.split("/").slice(-1).toString().replace(".js", "");
      }
    }
    if (typeof module !== "undefined") {
      var MODULE = module;
    }
    ;
    USE(function(module2) {
      var Type = {};
      Type.fn = {is: function(fn) {
        return !!fn && typeof fn == "function";
      }};
      Type.bi = {is: function(b) {
        return b instanceof Boolean || typeof b == "boolean";
      }};
      Type.num = {is: function(n) {
        return !list_is(n) && (n - parseFloat(n) + 1 >= 0 || n === Infinity || n === -Infinity);
      }};
      Type.text = {is: function(t) {
        return typeof t == "string";
      }};
      Type.text.ify = function(t) {
        if (Type.text.is(t)) {
          return t;
        }
        if (typeof JSON !== "undefined") {
          return JSON.stringify(t);
        }
        return t && t.toString ? t.toString() : t;
      };
      Type.text.random = function(l, c) {
        var s = "";
        l = l || 24;
        c = c || "0123456789ABCDEFGHIJKLMNOPQRSTUVWXZabcdefghijklmnopqrstuvwxyz";
        while (l > 0) {
          s += c.charAt(Math.floor(Math.random() * c.length));
          l--;
        }
        return s;
      };
      Type.text.match = function(t, o) {
        var tmp, u;
        if (typeof t !== "string") {
          return false;
        }
        if (typeof o == "string") {
          o = {"=": o};
        }
        o = o || {};
        tmp = o["="] || o["*"] || o[">"] || o["<"];
        if (t === tmp) {
          return true;
        }
        if (u !== o["="]) {
          return false;
        }
        tmp = o["*"] || o[">"] || o["<"];
        if (t.slice(0, (tmp || "").length) === tmp) {
          return true;
        }
        if (u !== o["*"]) {
          return false;
        }
        if (u !== o[">"] && u !== o["<"]) {
          return t >= o[">"] && t <= o["<"] ? true : false;
        }
        if (u !== o[">"] && t >= o[">"]) {
          return true;
        }
        if (u !== o["<"] && t <= o["<"]) {
          return true;
        }
        return false;
      };
      Type.text.hash = function(s, c) {
        if (typeof s !== "string") {
          return;
        }
        c = c || 0;
        if (!s.length) {
          return c;
        }
        for (var i = 0, l = s.length, n; i < l; ++i) {
          n = s.charCodeAt(i);
          c = (c << 5) - c + n;
          c |= 0;
        }
        return c;
      };
      Type.list = {is: function(l) {
        return l instanceof Array;
      }};
      Type.list.slit = Array.prototype.slice;
      Type.list.sort = function(k) {
        return function(A, B) {
          if (!A || !B) {
            return 0;
          }
          A = A[k];
          B = B[k];
          if (A < B) {
            return -1;
          } else if (A > B) {
            return 1;
          } else {
            return 0;
          }
        };
      };
      Type.list.map = function(l, c, _) {
        return obj_map(l, c, _);
      };
      Type.list.index = 1;
      Type.obj = {is: function(o) {
        return o ? o instanceof Object && o.constructor === Object || Object.prototype.toString.call(o).match(/^\[object (\w+)\]$/)[1] === "Object" : false;
      }};
      Type.obj.put = function(o, k, v) {
        return (o || {})[k] = v, o;
      };
      Type.obj.has = function(o, k) {
        return o && Object.prototype.hasOwnProperty.call(o, k);
      };
      Type.obj.del = function(o, k) {
        if (!o) {
          return;
        }
        o[k] = null;
        delete o[k];
        return o;
      };
      Type.obj.as = function(o, k, v, u) {
        return o[k] = o[k] || (u === v ? {} : v);
      };
      Type.obj.ify = function(o) {
        if (obj_is(o)) {
          return o;
        }
        try {
          o = JSON.parse(o);
        } catch (e) {
          o = {};
        }
        ;
        return o;
      };
      (function() {
        var u;
        function map(v, k) {
          if (obj_has(this, k) && u !== this[k]) {
            return;
          }
          this[k] = v;
        }
        Type.obj.to = function(from, to) {
          to = to || {};
          obj_map(from, map, to);
          return to;
        };
      })();
      Type.obj.copy = function(o) {
        return !o ? o : JSON.parse(JSON.stringify(o));
      };
      (function() {
        function empty(v, i) {
          var n = this.n, u;
          if (n && (i === n || obj_is(n) && obj_has(n, i))) {
            return;
          }
          if (u !== i) {
            return true;
          }
        }
        Type.obj.empty = function(o, n) {
          if (!o) {
            return true;
          }
          return obj_map(o, empty, {n}) ? false : true;
        };
      })();
      ;
      (function() {
        function t(k, v) {
          if (arguments.length === 2) {
            t.r = t.r || {};
            t.r[k] = v;
            return;
          }
          t.r = t.r || [];
          t.r.push(k);
        }
        ;
        var keys = Object.keys, map, u;
        Object.keys = Object.keys || function(o) {
          return map(o, function(v, k, t2) {
            t2(k);
          });
        };
        Type.obj.map = map = function(l, c, _) {
          var u2, i = 0, x, r, ll, lle, f = typeof c == "function";
          t.r = u2;
          if (keys && obj_is(l)) {
            ll = keys(l);
            lle = true;
          }
          _ = _ || {};
          if (list_is(l) || ll) {
            x = (ll || l).length;
            for (; i < x; i++) {
              var ii = i + Type.list.index;
              if (f) {
                r = lle ? c.call(_, l[ll[i]], ll[i], t) : c.call(_, l[i], ii, t);
                if (r !== u2) {
                  return r;
                }
              } else {
                if (c === l[lle ? ll[i] : i]) {
                  return ll ? ll[i] : ii;
                }
              }
            }
          } else {
            for (i in l) {
              if (f) {
                if (obj_has(l, i)) {
                  r = _ ? c.call(_, l[i], i, t) : c(l[i], i, t);
                  if (r !== u2) {
                    return r;
                  }
                }
              } else {
                if (c === l[i]) {
                  return i;
                }
              }
            }
          }
          return f ? t.r : Type.list.index ? 0 : -1;
        };
      })();
      Type.time = {};
      Type.time.is = function(t) {
        return t ? t instanceof Date : +new Date().getTime();
      };
      var fn_is = Type.fn.is;
      var list_is = Type.list.is;
      var obj = Type.obj, obj_is = obj.is, obj_has = obj.has, obj_map = obj.map;
      module2.exports = Type;
    })(USE, "./type");
    ;
    USE(function(module2) {
      module2.exports = function onto(tag, arg, as) {
        if (!tag) {
          return {to: onto};
        }
        var u, tag = (this.tag || (this.tag = {}))[tag] || (this.tag[tag] = {tag, to: onto._ = {
          next: function(arg2) {
            var tmp;
            if (tmp = this.to) {
              tmp.next(arg2);
            }
          }
        }});
        if (typeof arg == "function") {
          var be = {
            off: onto.off || (onto.off = function() {
              if (this.next === onto._.next) {
                return true;
              }
              if (this === this.the.last) {
                this.the.last = this.back;
              }
              this.to.back = this.back;
              this.next = onto._.next;
              this.back.to = this.to;
              if (this.the.last === this.the) {
                delete this.on.tag[this.the.tag];
              }
            }),
            to: onto._,
            next: arg,
            the: tag,
            on: this,
            as
          };
          (be.back = tag.last || tag).to = be;
          return tag.last = be;
        }
        if ((tag = tag.to) && u !== arg) {
          tag.next(arg);
        }
        return tag;
      };
    })(USE, "./onto");
    ;
    USE(function(module2) {
      var to = typeof setImmediate !== "undefined" ? setImmediate : setTimeout, puff = function(cb) {
        if (Q.length) {
          Q.push(cb);
          return;
        }
        Q = [cb];
        to(function go(S) {
          S = S || +new Date();
          var i = 0, cb2;
          while (i < 9 && (cb2 = Q[i++])) {
            cb2();
          }
          console.STAT && console.STAT(S, +new Date() - S, "puff");
          if (cb2 && !(+new Date() - S)) {
            return go(S);
          }
          if (!(Q = Q.slice(i)).length) {
            return;
          }
          to(go, 0);
        }, 0);
      }, Q = [];
      module2.exports = setTimeout.puff = puff;
    })(USE, "./puff");
    ;
    USE(function(module2) {
      function HAM(machineState, incomingState, currentState, incomingValue, currentValue) {
        if (machineState < incomingState) {
          return {defer: true};
        }
        if (incomingState < currentState) {
          return {historical: true};
        }
        if (currentState < incomingState) {
          return {converge: true, incoming: true};
        }
        if (incomingState === currentState) {
          incomingValue = Lexical(incomingValue) || "";
          currentValue = Lexical(currentValue) || "";
          if (incomingValue === currentValue) {
            return {state: true};
          }
          if (incomingValue < currentValue) {
            return {converge: true, current: true};
          }
          if (currentValue < incomingValue) {
            return {converge: true, incoming: true};
          }
        }
        return {err: "Invalid CRDT Data: " + incomingValue + " to " + currentValue + " at " + incomingState + " to " + currentState + "!"};
      }
      if (typeof JSON === "undefined") {
        throw new Error("JSON is not included in this browser. Please load it first: ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js");
      }
      var Lexical = JSON.stringify, undefined;
      module2.exports = HAM;
    })(USE, "./HAM");
    ;
    USE(function(module2) {
      var Type = USE("./type");
      var Val = {};
      Val.is = function(v) {
        if (v === u) {
          return false;
        }
        if (v === null) {
          return true;
        }
        if (v === Infinity) {
          return false;
        }
        if (text_is(v) || bi_is(v) || num_is(v)) {
          return true;
        }
        return Val.link.is(v) || false;
      };
      Val.link = Val.rel = {_: "#"};
      ;
      (function() {
        Val.link.is = function(v) {
          if (v && v[rel_] && !v._ && obj_is(v)) {
            var o = {};
            obj_map(v, map, o);
            if (o.id) {
              return o.id;
            }
          }
          return false;
        };
        function map(s, k) {
          var o = this;
          if (o.id) {
            return o.id = false;
          }
          if (k == rel_ && text_is(s)) {
            o.id = s;
          } else {
            return o.id = false;
          }
        }
      })();
      Val.link.ify = function(t) {
        return obj_put({}, rel_, t);
      };
      Type.obj.has._ = ".";
      var rel_ = Val.link._, u;
      var bi_is = Type.bi.is;
      var num_is = Type.num.is;
      var text_is = Type.text.is;
      var obj = Type.obj, obj_is = obj.is, obj_put = obj.put, obj_map = obj.map;
      module2.exports = Val;
    })(USE, "./val");
    ;
    USE(function(module2) {
      var Type = USE("./type");
      var Val = USE("./val");
      var Node = {_: "_"};
      Node.soul = function(n, o) {
        return n && n._ && n._[o || soul_];
      };
      Node.soul.ify = function(n, o) {
        o = typeof o === "string" ? {soul: o} : o || {};
        n = n || {};
        n._ = n._ || {};
        n._[soul_] = o.soul || n._[soul_] || text_random();
        return n;
      };
      Node.soul._ = Val.link._;
      ;
      (function() {
        Node.is = function(n, cb, as) {
          var s;
          if (!obj_is(n)) {
            return false;
          }
          if (s = Node.soul(n)) {
            return !obj_map(n, map, {as, cb, s, n});
          }
          return false;
        };
        function map(v, k) {
          if (k === Node._) {
            return;
          }
          if (!Val.is(v)) {
            return true;
          }
          if (this.cb) {
            this.cb.call(this.as, v, k, this.n, this.s);
          }
        }
      })();
      ;
      (function() {
        Node.ify = function(obj2, o, as) {
          if (!o) {
            o = {};
          } else if (typeof o === "string") {
            o = {soul: o};
          } else if (typeof o == "function") {
            o = {map: o};
          }
          if (o.map) {
            o.node = o.map.call(as, obj2, u, o.node || {});
          }
          if (o.node = Node.soul.ify(o.node || {}, o)) {
            obj_map(obj2, map, {o, as});
          }
          return o.node;
        };
        function map(v, k) {
          var o = this.o, tmp, u2;
          if (o.map) {
            tmp = o.map.call(this.as, v, "" + k, o.node);
            if (u2 === tmp) {
              obj_del(o.node, k);
            } else if (o.node) {
              o.node[k] = tmp;
            }
            return;
          }
          if (Val.is(v)) {
            o.node[k] = v;
          }
        }
      })();
      var obj = Type.obj, obj_is = obj.is, obj_del = obj.del, obj_map = obj.map;
      var text = Type.text, text_random = text.random;
      var soul_ = Node.soul._;
      var u;
      module2.exports = Node;
    })(USE, "./node");
    ;
    USE(function(module2) {
      var Type = USE("./type");
      var Node = USE("./node");
      function State() {
        var t;
        t = +new Date();
        if (last < t) {
          return N = 0, last = t + State.drift;
        }
        return last = t + (N += 1) / D + State.drift;
      }
      var time = Type.time.is, last = -Infinity, N = 0, D = 1e3;
      var perf = typeof performance !== "undefined" ? performance.timing && performance : false, start = perf && perf.timing && perf.timing.navigationStart || (perf = false);
      var S_ = State._ = ">";
      State.drift = 0;
      State.is = function(n, k, o) {
        var tmp = k && n && n[N_] && n[N_][S_] || o;
        if (!tmp) {
          return;
        }
        return num_is(tmp = tmp[k]) ? tmp : -Infinity;
      };
      State.lex = function() {
        return State().toString(36).replace(".", "");
      };
      State.ify = function(n, k, s, v, soul) {
        if (!n || !n[N_]) {
          if (!soul) {
            return;
          }
          n = Node.soul.ify(n, soul);
        }
        var tmp = obj_as(n[N_], S_);
        if (u !== k && k !== N_) {
          if (num_is(s)) {
            tmp[k] = s;
          }
          if (u !== v) {
            n[k] = v;
          }
        }
        return n;
      };
      State.to = function(from, k, to) {
        var val = (from || {})[k];
        if (obj_is(val)) {
          val = obj_copy(val);
        }
        return State.ify(to, k, State.is(from, k), val, Node.soul(from));
      };
      (function() {
        State.map = function(cb, s, as) {
          var u2;
          var o = obj_is(o = cb || s) ? o : null;
          cb = fn_is(cb = cb || s) ? cb : null;
          if (o && !cb) {
            s = num_is(s) ? s : State();
            o[N_] = o[N_] || {};
            obj_map(o, map, {o, s});
            return o;
          }
          as = as || obj_is(s) ? s : u2;
          s = num_is(s) ? s : State();
          return function(v, k, o2, opt) {
            if (!cb) {
              map.call({o: o2, s}, v, k);
              return v;
            }
            cb.call(as || this || {}, v, k, o2, opt);
            if (obj_has(o2, k) && u2 === o2[k]) {
              return;
            }
            map.call({o: o2, s}, v, k);
          };
        };
        function map(v, k) {
          if (N_ === k) {
            return;
          }
          State.ify(this.o, k, this.s);
        }
      })();
      var obj = Type.obj, obj_as = obj.as, obj_has = obj.has, obj_is = obj.is, obj_map = obj.map, obj_copy = obj.copy;
      var num = Type.num, num_is = num.is;
      var fn = Type.fn, fn_is = fn.is;
      var N_ = Node._, u;
      module2.exports = State;
    })(USE, "./state");
    ;
    USE(function(module2) {
      var Type = USE("./type");
      var Val = USE("./val");
      var Node = USE("./node");
      var Graph = {};
      ;
      (function() {
        Graph.is = function(g, cb, fn, as) {
          if (!g || !obj_is(g) || obj_empty(g)) {
            return false;
          }
          return !obj_map(g, map, {cb, fn, as});
        };
        function map(n, s) {
          if (!n || s !== Node.soul(n) || !Node.is(n, this.fn, this.as)) {
            return true;
          }
          if (!this.cb) {
            return;
          }
          nf.n = n;
          nf.as = this.as;
          this.cb.call(nf.as, n, s, nf);
        }
        function nf(fn) {
          if (fn) {
            Node.is(nf.n, fn, nf.as);
          }
        }
      })();
      ;
      (function() {
        Graph.ify = function(obj2, env, as) {
          var at = {path: [], obj: obj2};
          if (!env) {
            env = {};
          } else if (typeof env === "string") {
            env = {soul: env};
          } else if (typeof env == "function") {
            env.map = env;
          }
          if (typeof as === "string") {
            env.soul = env.soul || as;
            as = u;
          }
          if (env.soul) {
            at.link = Val.link.ify(env.soul);
          }
          env.shell = (as || {}).shell;
          env.graph = env.graph || {};
          env.seen = env.seen || [];
          env.as = env.as || as;
          node(env, at);
          env.root = at.node;
          return env.graph;
        };
        function node(env, at) {
          var tmp;
          if (tmp = seen(env, at)) {
            return tmp;
          }
          at.env = env;
          at.soul = soul;
          if (Node.ify(at.obj, map, at)) {
            at.link = at.link || Val.link.ify(Node.soul(at.node));
            if (at.obj !== env.shell) {
              env.graph[Val.link.is(at.link)] = at.node;
            }
          }
          return at;
        }
        function map(v, k, n) {
          var at = this, env = at.env, is, tmp;
          if (Node._ === k && obj_has(v, Val.link._)) {
            return n._;
          }
          if (!(is = valid(v, k, n, at, env))) {
            return;
          }
          if (!k) {
            at.node = at.node || n || {};
            if (obj_has(v, Node._) && Node.soul(v)) {
              at.node._ = obj_copy(v._);
            }
            at.node = Node.soul.ify(at.node, Val.link.is(at.link));
            at.link = at.link || Val.link.ify(Node.soul(at.node));
          }
          if (tmp = env.map) {
            tmp.call(env.as || {}, v, k, n, at);
            if (obj_has(n, k)) {
              v = n[k];
              if (u === v) {
                obj_del(n, k);
                return;
              }
              if (!(is = valid(v, k, n, at, env))) {
                return;
              }
            }
          }
          if (!k) {
            return at.node;
          }
          if (is === true) {
            return v;
          }
          tmp = node(env, {obj: v, path: at.path.concat(k)});
          if (!tmp.node) {
            return;
          }
          return tmp.link;
        }
        function soul(id) {
          var at = this;
          var prev = Val.link.is(at.link), graph = at.env.graph;
          at.link = at.link || Val.link.ify(id);
          at.link[Val.link._] = id;
          if (at.node && at.node[Node._]) {
            at.node[Node._][Val.link._] = id;
          }
          if (obj_has(graph, prev)) {
            graph[id] = graph[prev];
            obj_del(graph, prev);
          }
        }
        function valid(v, k, n, at, env) {
          var tmp;
          if (Val.is(v)) {
            return true;
          }
          if (obj_is(v)) {
            return 1;
          }
          if (tmp = env.invalid) {
            v = tmp.call(env.as || {}, v, k, n);
            return valid(v, k, n, at, env);
          }
          env.err = "Invalid value at '" + at.path.concat(k).join(".") + "'!";
          if (Type.list.is(v)) {
            env.err += " Use `.set(item)` instead of an Array.";
          }
        }
        function seen(env, at) {
          var arr = env.seen, i = arr.length, has;
          while (i--) {
            has = arr[i];
            if (at.obj === has.obj) {
              return has;
            }
          }
          arr.push(at);
        }
      })();
      Graph.node = function(node) {
        var soul = Node.soul(node);
        if (!soul) {
          return;
        }
        return obj_put({}, soul, node);
      };
      (function() {
        Graph.to = function(graph, root, opt) {
          if (!graph) {
            return;
          }
          var obj2 = {};
          opt = opt || {seen: {}};
          obj_map(graph[root], map, {obj: obj2, graph, opt});
          return obj2;
        };
        function map(v, k) {
          var tmp, obj2;
          if (Node._ === k) {
            if (obj_empty(v, Val.link._)) {
              return;
            }
            this.obj[k] = obj_copy(v);
            return;
          }
          if (!(tmp = Val.link.is(v))) {
            this.obj[k] = v;
            return;
          }
          if (obj2 = this.opt.seen[tmp]) {
            this.obj[k] = obj2;
            return;
          }
          this.obj[k] = this.opt.seen[tmp] = Graph.to(this.graph, tmp, this.opt);
        }
      })();
      var fn_is = Type.fn.is;
      var obj = Type.obj, obj_is = obj.is, obj_del = obj.del, obj_has = obj.has, obj_empty = obj.empty, obj_put = obj.put, obj_map = obj.map, obj_copy = obj.copy;
      var u;
      module2.exports = Graph;
    })(USE, "./graph");
    ;
    USE(function(module2) {
      USE("./onto");
      module2.exports = function ask(cb, as) {
        if (!this.on) {
          return;
        }
        if (!(typeof cb == "function")) {
          if (!cb || !as) {
            return;
          }
          var id = cb["#"] || cb, tmp = (this.tag || "")[id];
          if (!tmp) {
            return;
          }
          tmp = this.on(id, as);
          clearTimeout(tmp.err);
          return true;
        }
        var id = as && as["#"] || Math.random().toString(36).slice(2);
        if (!cb) {
          return id;
        }
        var to = this.on(id, cb, as);
        to.err = to.err || setTimeout(function() {
          to.next({err: "Error: No ACK yet.", lack: true});
          to.off();
        }, (this.opt || {}).lack || 9e3);
        return id;
      };
    })(USE, "./ask");
    ;
    USE(function(module2) {
      var Type = USE("./type");
      function Dup(opt) {
        var dup = {s: {}}, s = dup.s;
        opt = opt || {max: 1e3, age: 1e3 * 9 * 3};
        dup.check = function(id) {
          if (!s[id]) {
            return false;
          }
          return dt(id);
        };
        var dt = dup.track = function(id) {
          var it = s[id] || (s[id] = {});
          it.was = +new Date();
          if (!dup.to) {
            dup.to = setTimeout(dup.drop, opt.age + 9);
          }
          return it;
        };
        dup.drop = function(age) {
          var now = +new Date();
          Type.obj.map(s, function(it, id) {
            if (it && (age || opt.age) > now - it.was) {
              return;
            }
            delete s[id];
          });
          dup.to = null;
          console.STAT && (age = +new Date() - now) > 9 && console.STAT(now, age, "dup drop");
        };
        return dup;
      }
      module2.exports = Dup;
    })(USE, "./dup");
    ;
    USE(function(module2) {
      function Gun2(o) {
        if (o instanceof Gun2) {
          return (this._ = {$: this}).$;
        }
        if (!(this instanceof Gun2)) {
          return new Gun2(o);
        }
        return Gun2.create(this._ = {$: this, opt: o});
      }
      Gun2.is = function($) {
        return $ instanceof Gun2 || $ && $._ && $ === $._.$ || false;
      };
      Gun2.version = 0.202;
      Gun2.chain = Gun2.prototype;
      Gun2.chain.toJSON = function() {
      };
      var Type = USE("./type");
      Type.obj.to(Type, Gun2);
      Gun2.HAM = USE("./HAM");
      Gun2.val = USE("./val");
      Gun2.node = USE("./node");
      Gun2.state = USE("./state");
      Gun2.graph = USE("./graph");
      Gun2.on = USE("./onto");
      Gun2.ask = USE("./ask");
      Gun2.dup = USE("./dup");
      Gun2.puff = USE("./puff");
      ;
      (function() {
        Gun2.create = function(at) {
          at.root = at.root || at;
          at.graph = at.graph || {};
          at.on = at.on || Gun2.on;
          at.ask = at.ask || Gun2.ask;
          at.dup = at.dup || Gun2.dup();
          var gun = at.$.opt(at.opt);
          if (!at.once) {
            at.on("in", universe, at);
            at.on("out", universe, at);
            at.on("put", map, at);
            Gun2.on("create", at);
            at.on("create", at);
          }
          at.once = 1;
          return gun;
        };
        function universe(msg) {
          if (!msg) {
            return;
          }
          if (msg.out === universe) {
            this.to.next(msg);
            return;
          }
          var eve = this, as = eve.as, at = as.at || as, gun = at.$, dup = at.dup, tmp, DBG = msg.DBG;
          (tmp = msg["#"]) || (tmp = msg["#"] = text_rand(9));
          if (dup.check(tmp)) {
            return;
          }
          dup.track(tmp);
          tmp = msg._;
          msg._ = typeof tmp == "function" ? tmp : function() {
          };
          msg.$ && msg.$ === (msg.$._ || "").$ || (msg.$ = gun);
          if (!at.ask(msg["@"], msg)) {
            DBG && (DBG.u = +new Date());
            if (msg.get) {
              Gun2.on._get(msg, gun);
            }
            if (msg.put) {
              put(msg);
              return;
            }
          }
          DBG && (DBG.uc = +new Date());
          eve.to.next(msg);
          DBG && (DBG.ua = +new Date());
          msg.out = universe;
          at.on("out", msg);
          DBG && (DBG.ue = +new Date());
        }
        function put(msg) {
          if (!msg) {
            return;
          }
          var ctx = msg._ || "", root = ctx.root = ((ctx.$ = msg.$ || "")._ || "").root;
          var put2 = msg.put, id = msg["#"], err2, tmp;
          var DBG = ctx.DBG = msg.DBG;
          if (put2["#"] && put2["."]) {
            root.on("put", msg);
            return;
          }
          ctx.out = msg;
          ctx.lot = {s: 0, more: 1};
          var S = +new Date();
          DBG && (DBG.p = S);
          for (var soul in put2) {
            var node = put2[soul], states;
            if (!node) {
              err2 = ERR + cut(soul) + "no node.";
              break;
            }
            if (!(tmp = node._)) {
              err2 = ERR + cut(soul) + "no meta.";
              break;
            }
            if (soul !== tmp[_soul]) {
              err2 = ERR + cut(soul) + "soul not same.";
              break;
            }
            if (!(states = tmp[state_])) {
              err2 = ERR + cut(soul) + "no state.";
              break;
            }
            for (var key in node) {
              if (node_ === key) {
                continue;
              }
              var val = node[key], state = states[key];
              if (u === state) {
                err2 = ERR + cut(key) + "on" + cut(soul) + "no state.";
                break;
              }
              if (!val_is(val)) {
                err2 = ERR + cut(key) + "on" + cut(soul) + "bad " + typeof val + cut(val);
                break;
              }
              ham(val, key, soul, state, msg);
            }
            if (err2) {
              break;
            }
          }
          DBG && (DBG.pe = +new Date());
          if (console.STAT) {
            console.STAT(S, +new Date() - S, "mix");
            console.STAT(S, ctx.lot.s, "mix #");
          }
          if (ctx.err = err2) {
            root.on("in", {"@": id, err: Gun2.log(err2)});
            return;
          }
          if (!--ctx.lot.more) {
            fire(ctx);
          }
          if (!ctx.stun && !msg["@"]) {
            root.on("in", {"@": id, ok: -1});
          }
        }
        Gun2.on.put = put;
        function ham(val, key, soul, state, msg) {
          var ctx = msg._ || "", root = ctx.root, graph = root.graph, lot;
          var vertex = graph[soul] || empty, was = state_is(vertex, key, 1), known = vertex[key];
          var machine = State(), is = HAM(machine, state, was, val, known), u2;
          if (!is.incoming) {
            if (is.defer) {
              var to = state - machine;
              setTimeout(function() {
                ham(val, key, soul, state, msg);
              }, to > MD2 ? MD2 : to);
              if (!ctx.to) {
                root.on("in", {"@": msg["#"], err: to});
              }
              ctx.to = 1;
              return to;
            }
            if (!ctx.miss) {
              return;
            }
          }
          (lot = ctx.lot || "").s++;
          lot.more++;
          (ctx.stun || (ctx.stun = {}))[soul + key] = 1;
          var DBG = ctx.DBG;
          DBG && (DBG.ph = DBG.ph || +new Date());
          root.on("put", {"#": msg["#"], "@": msg["@"], put: {"#": soul, ".": key, ":": val, ">": state}, _: ctx});
        }
        function map(msg) {
          var DBG;
          if (DBG = (msg._ || "").DBG) {
            DBG.pa = +new Date();
            DBG.pm = DBG.pm || +new Date();
          }
          var eve = this, root = eve.as, graph = root.graph, ctx = msg._, put2 = msg.put, soul = put2["#"], key = put2["."], val = put2[":"], state = put2[">"], id = msg["#"], tmp;
          graph[soul] = state_ify(graph[soul], key, state, val, soul);
          chain(ctx, soul, key, u !== (tmp = put2["="]) ? tmp : val, state);
          if ((tmp = ctx.out) && (tmp = tmp.put)) {
            tmp[soul] = state_ify(tmp[soul], key, state, val, soul);
          }
          if (!--ctx.lot.more) {
            fire(ctx);
          }
          eve.to.next(msg);
        }
        function chain(ctx, soul, key, val, state) {
          var root = ctx.root, put2, tmp;
          (root.opt || "").super && root.$.get(soul);
          if (!root || !(tmp = root.next) || !(tmp = tmp[soul]) || !tmp.$) {
            return;
          }
          (put2 = ctx.put || (ctx.put = {}))[soul] = state_ify(put2[soul], key, state, val, soul);
          tmp.put = state_ify(tmp.put, key, state, val, soul);
        }
        function fire(ctx) {
          if (ctx.err) {
            return;
          }
          var stop = {};
          var root = ((ctx.$ || "")._ || "").root, next = (root || "").next || "", put2 = ctx.put, tmp;
          var S = +new Date();
          for (var soul in put2) {
            var node = put2[soul];
            if (!(tmp = next[soul]) || !tmp.$) {
              continue;
            }
            root.stop = stop;
            tmp.on("in", {$: tmp.$, get: soul, put: node});
            root.stop = null;
          }
          console.STAT && console.STAT(S, +new Date() - S, "fire");
          ctx.DBG && (ctx.DBG.f = +new Date());
          if (!(tmp = ctx.out)) {
            return;
          }
          tmp.out = universe;
          root.on("out", tmp);
        }
        var ERR = "Error: Invalid graph!";
        var cut = function(s) {
          return " '" + ("" + s).slice(0, 9) + "...' ";
        };
        var HAM = Gun2.HAM, MD2 = 2147483647, State = Gun2.state;
      })();
      ;
      (function() {
        Gun2.on._put = function(msg, gun) {
          var at = gun._, ctx = {$: gun, graph: at.graph, put: {}, map: {}, souls: {}, machine: Gun2.state(), ack: msg["@"], cat: at, stop: {}};
          if (!Gun2.obj.map(msg.put, perf, ctx)) {
            return;
          }
          if (!Gun2.graph.is(msg.put, null, verify, ctx)) {
            ctx.err = "Error: Invalid graph!";
          }
          if (ctx.err) {
            return at.on("in", {"@": msg["#"], err: Gun2.log(ctx.err)});
          }
          obj_map(ctx.put, merge, ctx);
          if (!ctx.async) {
            obj_map(ctx.map, map, ctx);
          }
          if (u !== ctx.defer) {
            var to = ctx.defer - ctx.machine;
            setTimeout(function() {
              Gun2.on._put(msg, gun);
            }, to > MD ? MD : to);
          }
          if (!ctx.diff) {
            return;
          }
          at.on("put", obj_to(msg, {put: ctx.diff}));
        };
        function verify(val, key, node, soul) {
          var ctx = this;
          var state = Gun2.state.is(node, key), tmp;
          if (!state) {
            return ctx.err = "Error: No state on '" + key + "' in node '" + soul + "'!";
          }
          var vertex = ctx.graph[soul] || empty, was = Gun2.state.is(vertex, key, true), known = vertex[key];
          var HAM = Gun2.HAM(ctx.machine, state, was, val, known);
          if (!HAM.incoming) {
            if (HAM.defer) {
              ctx.defer = state < (ctx.defer || Infinity) ? state : ctx.defer;
            }
            return;
          }
          ctx.put[soul] = Gun2.state.to(node, key, ctx.put[soul]);
          (ctx.diff || (ctx.diff = {}))[soul] = Gun2.state.to(node, key, ctx.diff[soul]);
          ctx.souls[soul] = true;
        }
        function merge(node, soul) {
          var ctx = this, cat = ctx.$._, at = (cat.next || empty)[soul];
          if (!at) {
            if (!(cat.opt || empty).super) {
              ctx.souls[soul] = false;
              return;
            }
            at = ctx.$.get(soul)._;
          }
          var msg = ctx.map[soul] = {
            put: node,
            get: soul,
            $: at.$
          }, as = {ctx, msg};
          ctx.async = !!cat.tag.node;
          if (ctx.ack) {
            msg["@"] = ctx.ack;
          }
          obj_map(node, each, as);
          if (!ctx.async) {
            return;
          }
          if (!ctx.and) {
            cat.on("node", function(m) {
              this.to.next(m);
              if (m !== ctx.map[m.get]) {
                return;
              }
              ctx.souls[m.get] = false;
              obj_map(m.put, patch, m);
              if (obj_map(ctx.souls, function(v) {
                if (v) {
                  return v;
                }
              })) {
                return;
              }
              if (ctx.c) {
                return;
              }
              ctx.c = 1;
              this.off();
              obj_map(ctx.map, map, ctx);
            });
          }
          ctx.and = true;
          cat.on("node", msg);
        }
        function each(val, key) {
          var ctx = this.ctx, graph = ctx.graph, msg = this.msg, soul = msg.get, node = msg.put, at = msg.$._, tmp;
          graph[soul] = Gun2.state.to(node, key, graph[soul]);
          if (ctx.async) {
            return;
          }
          at.put = Gun2.state.to(node, key, at.put);
        }
        function patch(val, key) {
          var msg = this, node = msg.put, at = msg.$._;
          at.put = Gun2.state.to(node, key, at.put);
        }
        function map(msg, soul) {
          if (!msg.$) {
            return;
          }
          this.cat.stop = this.stop;
          msg.$._.on("in", msg);
          this.cat.stop = null;
        }
        function perf(node, soul) {
          if (node !== this.graph[soul]) {
            return true;
          }
        }
        Gun2.on._get = function(msg, gun) {
          var root = gun._, get = msg.get, soul = get[_soul], node = root.graph[soul], has = get[_has], tmp;
          var next = root.next || (root.next = {}), at = next[soul];
          var ctx = msg._ || "", DBG = ctx.DBG = msg.DBG;
          DBG && (DBG.g = +new Date());
          if (!node) {
            return root.on("get", msg);
          }
          if (has) {
            if (typeof has != "string" || !obj_has(node, has)) {
              return root.on("get", msg);
            }
            node = Gun2.state.to(node, has);
          } else {
            node = Gun2.window ? Gun2.obj.copy(node) : node;
          }
          node = Gun2.graph.node(node);
          tmp = (at || empty).ack;
          var faith = function() {
          };
          faith.ram = faith.faith = true;
          faith.$ = msg.$;
          DBG && (DBG.ga = +new Date());
          root.on("in", {
            "@": msg["#"],
            put: node,
            ram: 1,
            $: gun,
            _: faith
          });
          DBG && (DBG.gm = +new Date());
          root.on("get", msg);
          DBG && (DBG.gd = +new Date());
        };
      })();
      ;
      (function() {
        Gun2.chain.opt = function(opt) {
          opt = opt || {};
          var gun = this, at = gun._, tmp = opt.peers || opt;
          if (!obj_is(opt)) {
            opt = {};
          }
          if (!obj_is(at.opt)) {
            at.opt = opt;
          }
          if (text_is(tmp)) {
            tmp = [tmp];
          }
          if (list_is(tmp)) {
            tmp = obj_map(tmp, function(url, i, map) {
              i = {};
              i.id = i.url = url;
              map(url, i);
            });
            if (!obj_is(at.opt.peers)) {
              at.opt.peers = {};
            }
            at.opt.peers = obj_to(tmp, at.opt.peers);
          }
          at.opt.peers = at.opt.peers || {};
          obj_map(opt, function each(v, k) {
            if (!obj_has(this, k) || text.is(v) || obj.empty(v)) {
              this[k] = v;
              return;
            }
            if (v && v.constructor !== Object && !list_is(v)) {
              return;
            }
            obj_map(v, each, this[k]);
          }, at.opt);
          Gun2.on("opt", at);
          Gun2.obj.native();
          return gun;
        };
      })();
      Gun2.obj.native = function() {
        var p = Object.prototype;
        for (var i in p) {
          console.log("Native Object.prototype polluted, reverting", i);
          delete p[i];
        }
      };
      var list_is = Gun2.list.is;
      var text = Gun2.text, text_is = text.is, text_rand = text.random;
      var obj = Gun2.obj, obj_empty = obj.empty, obj_is = obj.is, obj_has = obj.has, obj_to = obj.to, obj_map = obj.map, obj_copy = obj.copy;
      var state_lex = Gun2.state.lex, state_ify = Gun2.state.ify, state_is = Gun2.state.is, _soul = Gun2.val.link._, _has = ".", node_ = Gun2.node._, val_is = Gun2.val.is, rel_is = Gun2.val.link.is, state_ = Gun2.state._;
      var empty = {}, u;
      var C;
      Gun2.log = function() {
        return !Gun2.log.off && C.log.apply(C, arguments), [].slice.call(arguments).join(" ");
      };
      Gun2.log.once = function(w, s, o) {
        return (o = Gun2.log.once)[w] = o[w] || 0, o[w]++ || Gun2.log(s);
      };
      if (typeof window !== "undefined") {
        (window.GUN = window.Gun = Gun2).window = window;
      }
      try {
        if (typeof MODULE !== "undefined") {
          MODULE.exports = Gun2;
        }
      } catch (e) {
      }
      module2.exports = Gun2;
      (Gun2.window || "").console = (Gun2.window || "").console || {log: function() {
      }};
      (C = console).only = function(i, s) {
        return C.only.i && i === C.only.i && C.only.i++ && (C.log.apply(C, arguments) || s);
      };
      ;
      "Please do not remove welcome log unless you are paying for a monthly sponsorship, thanks!";
      Gun2.log.once("welcome", "Hello wonderful person! :) Thanks for using GUN, please ask for help on http://chat.gun.eco if anything takes you longer than 5min to figure out!");
    })(USE, "./root");
    ;
    USE(function(module2) {
      var Gun2 = USE("./root");
      Gun2.chain.back = function(n, opt) {
        var tmp;
        n = n || 1;
        if (n === -1 || n === Infinity) {
          return this._.root.$;
        } else if (n === 1) {
          return (this._.back || this._).$;
        }
        var gun = this, at = gun._;
        if (typeof n === "string") {
          n = n.split(".");
        }
        if (n instanceof Array) {
          var i = 0, l = n.length, tmp = at;
          for (i; i < l; i++) {
            tmp = (tmp || empty)[n[i]];
          }
          if (u !== tmp) {
            return opt ? gun : tmp;
          } else if (tmp = at.back) {
            return tmp.$.back(n, opt);
          }
          return;
        }
        if (typeof n == "function") {
          var yes, tmp = {back: at};
          while ((tmp = tmp.back) && u === (yes = n(tmp, opt))) {
          }
          return yes;
        }
        if (Gun2.num.is(n)) {
          return (at.back || at).$.back(n - 1);
        }
        return this;
      };
      var empty = {}, u;
    })(USE, "./back");
    ;
    USE(function(module2) {
      var Gun2 = USE("./root");
      Gun2.chain.chain = function(sub) {
        var gun = this, at = gun._, chain = new (sub || gun).constructor(gun), cat = chain._, root;
        cat.root = root = at.root;
        cat.id = ++root.once;
        cat.back = gun._;
        cat.on = Gun2.on;
        cat.on("in", input, cat);
        cat.on("out", output, cat);
        return chain;
      };
      function output(msg) {
        var put, get, at = this.as, back = at.back, root = at.root, tmp;
        if (!msg.$) {
          msg.$ = at.$;
        }
        this.to.next(msg);
        if (get = msg.get) {
          if (at.lex) {
            msg.get = obj_to(at.lex, msg.get);
          }
          if (get["#"] || at.soul) {
            get["#"] = get["#"] || at.soul;
            msg["#"] || (msg["#"] = text_rand(9));
            back = root.$.get(get["#"])._;
            if (!(get = get["."])) {
              tmp = back.ack;
              if (!tmp) {
                back.ack = -1;
              }
              if (obj_has(back, "put")) {
                back.on("in", back);
              }
              if (tmp && u !== back.put) {
                return;
              }
              msg.$ = back.$;
            } else if (obj_has(back.put, get)) {
              put = back.$.get(get)._;
              if (!(tmp = put.ack)) {
                put.ack = -1;
              }
              back.on("in", {
                $: back.$,
                put: Gun2.state.to(back.put, get),
                get: back.get
              });
              if (tmp) {
                return;
              }
            } else if (typeof get != "string") {
              var put = {}, meta = (back.put || {})._;
              Gun2.obj.map(back.put, function(v, k) {
                if (!Gun2.text.match(k, get)) {
                  return;
                }
                put[k] = v;
              });
              if (!Gun2.obj.empty(put)) {
                put._ = meta;
                back.on("in", {$: back.$, put, get: back.get});
              }
              if (tmp = at.lex) {
                tmp = tmp._ || (tmp._ = function() {
                });
                if (back.ack < tmp.ask) {
                  tmp.ask = back.ack;
                }
                if (tmp.ask) {
                  return;
                }
                tmp.ask = 1;
              }
            }
            root.ask(ack, msg);
            return root.on("in", msg);
          }
          if (root.now) {
            root.now[at.id] = root.now[at.id] || true;
            at.pass = {};
          }
          if (get["."]) {
            if (at.get) {
              msg = {get: {".": at.get}, $: at.$};
              back.ask || (back.ask = {});
              back.ask[at.get] = msg.$._;
              return back.on("out", msg);
            }
            msg = {get: {}, $: at.$};
            return back.on("out", msg);
          }
          at.ack = at.ack || -1;
          if (at.get) {
            msg.$ = at.$;
            get["."] = at.get;
            (back.ask || (back.ask = {}))[at.get] = msg.$._;
            return back.on("out", msg);
          }
        }
        return back.on("out", msg);
      }
      function input(msg) {
        var eve = this, cat = eve.as, root = cat.root, gun = msg.$, at = (gun || empty)._ || empty, change = msg.put, rel, tmp;
        if (cat.get && msg.get !== cat.get) {
          msg = obj_to(msg, {get: cat.get});
        }
        if (cat.has && at !== cat) {
          msg = obj_to(msg, {$: cat.$});
          if (at.ack) {
            cat.ack = at.ack;
          }
        }
        if (u === change) {
          tmp = at.put;
          eve.to.next(msg);
          if (cat.soul) {
            return;
          }
          if (u === tmp && u !== at.put) {
            return;
          }
          echo(cat, msg, eve);
          if (cat.has) {
            not(cat, msg);
          }
          obj_del(at.echo, cat.id);
          obj_del(cat.map, at.id);
          return;
        }
        if (cat.soul) {
          eve.to.next(msg);
          echo(cat, msg, eve);
          if (cat.next) {
            obj_map(change, map, {msg, cat});
          }
          return;
        }
        if (!(rel = Gun2.val.link.is(change))) {
          if (Gun2.val.is(change)) {
            if (cat.has || cat.soul) {
              not(cat, msg);
            } else if (at.has || at.soul) {
              (at.echo || (at.echo = {}))[cat.id] = at.echo[at.id] || cat;
              (cat.map || (cat.map = {}))[at.id] = cat.map[at.id] || {at};
            }
            eve.to.next(msg);
            echo(cat, msg, eve);
            return;
          }
          if (cat.has && at !== cat && obj_has(at, "put")) {
            cat.put = at.put;
          }
          ;
          if ((rel = Gun2.node.soul(change)) && at.has) {
            at.put = cat.root.$.get(rel)._.put;
          }
          tmp = (root.stop || {})[at.id];
          eve.to.next(msg);
          relate(cat, msg, at, rel);
          echo(cat, msg, eve);
          if (cat.next) {
            obj_map(change, map, {msg, cat});
          }
          return;
        }
        var was = root.stop;
        tmp = root.stop || {};
        tmp = tmp[at.id] || (tmp[at.id] = {});
        tmp.is = tmp.is || at.put;
        tmp[cat.id] = at.put || true;
        eve.to.next(msg);
        relate(cat, msg, at, rel);
        echo(cat, msg, eve);
      }
      function relate(at, msg, from, rel) {
        if (!rel || node_ === at.get) {
          return;
        }
        var tmp = at.root.$.get(rel)._;
        if (at.has) {
          from = tmp;
        } else if (from.has) {
          relate(from, msg, from, rel);
        }
        if (from === at) {
          return;
        }
        if (!from.$) {
          from = {};
        }
        (from.echo || (from.echo = {}))[at.id] = from.echo[at.id] || at;
        if (at.has && !(at.map || empty)[from.id]) {
          not(at, msg);
        }
        tmp = from.id ? (at.map || (at.map = {}))[from.id] = at.map[from.id] || {at: from} : {};
        if (rel === tmp.link) {
          if (!(tmp.pass || at.pass)) {
            return;
          }
        }
        if (at.pass) {
          Gun2.obj.map(at.map, function(tmp2) {
            tmp2.pass = true;
          });
          obj_del(at, "pass");
        }
        if (tmp.pass) {
          obj_del(tmp, "pass");
        }
        if (at.has) {
          at.link = rel;
        }
        ask(at, tmp.link = rel);
      }
      function echo(at, msg, ev) {
        if (!at.echo) {
          return;
        }
        obj_map(at.echo, reverb, msg);
      }
      function reverb(to) {
        if (!to || !to.on) {
          return;
        }
        to.on("in", this);
      }
      function map(data, key) {
        var cat = this.cat, next = cat.next || empty, via = this.msg, chain, at, tmp;
        if (node_ === key && !next[key]) {
          return;
        }
        if (!(at = next[key])) {
          return;
        }
        if (at.has) {
          if (u === at.put || !Gun2.val.link.is(data)) {
            at.put = data;
          }
          chain = at.$;
        } else if (tmp = via.$) {
          tmp = (chain = via.$.get(key))._;
          if (u === tmp.put || !Gun2.val.link.is(data)) {
            tmp.put = data;
          }
        }
        at.on("in", {
          put: data,
          get: key,
          $: chain,
          via
        });
      }
      function not(at, msg) {
        if (!(at.has || at.soul)) {
          return;
        }
        var tmp = at.map, root = at.root;
        at.map = null;
        if (at.has) {
          if (at.dub && at.root.stop) {
            at.dub = null;
          }
          at.link = null;
        }
        if (!at.pass) {
          if (!msg["@"] && tmp === null) {
            return;
          }
        }
        if (u === tmp && Gun2.val.link.is(at.put)) {
          return;
        }
        obj_map(tmp, function(proxy) {
          if (!(proxy = proxy.at)) {
            return;
          }
          obj_del(proxy.echo, at.id);
        });
        tmp = at.put;
        obj_map(at.next, function(neat, key) {
          if (u === tmp && u !== at.put) {
            return true;
          }
          neat.put = u;
          if (neat.ack) {
            neat.ack = -1;
          }
          neat.on("in", {
            get: key,
            $: neat.$,
            put: u
          });
        });
      }
      function ask(at, soul) {
        var tmp = at.root.$.get(soul)._, lex = at.lex;
        if (at.ack || lex) {
          (lex = lex || {})["#"] = soul;
          tmp.on("out", {get: lex});
          if (!at.ask) {
            return;
          }
        }
        tmp = at.ask;
        Gun2.obj.del(at, "ask");
        obj_map(tmp || at.next, function(neat, key) {
          var lex2 = neat.lex || {};
          lex2["#"] = soul;
          lex2["."] = lex2["."] || key;
          neat.on("out", {get: lex2});
        });
        Gun2.obj.del(at, "ask");
      }
      function ack(msg, ev) {
        var as = this.as, get = as.get || "", at = as.$._, tmp = (msg.put || "")[get["#"]];
        if (at.ack) {
          at.ack = at.ack + 1 || 1;
        }
        if (!msg.put || typeof get["."] == "string" && !obj_has(tmp, at.get)) {
          if (at.put !== u) {
            return;
          }
          at.on("in", {
            get: at.get,
            put: at.put = u,
            $: at.$,
            "@": msg["@"]
          });
          return;
        }
        if (node_ == get["."]) {
          at.on("in", {get: at.get, put: Gun2.val.link.ify(get["#"]), $: at.$, "@": msg["@"]});
          return;
        }
        if (at.$ === (msg._ || "").$) {
          msg._.miss = at.put === u;
        }
        Gun2.on.put(msg);
      }
      var empty = {}, u;
      var obj = Gun2.obj, obj_has = obj.has, obj_put = obj.put, obj_del = obj.del, obj_to = obj.to, obj_map = obj.map;
      var text_rand = Gun2.text.random;
      var _soul = Gun2.val.link._, node_ = Gun2.node._;
    })(USE, "./chain");
    ;
    USE(function(module2) {
      var Gun2 = USE("./root");
      Gun2.chain.get = function(key, cb, as) {
        var gun, tmp;
        if (typeof key === "string") {
          var back = this, cat = back._;
          var next = cat.next || empty;
          if (!(gun = next[key])) {
            gun = cache(key, back);
          }
          gun = gun.$;
        } else if (typeof key == "function") {
          if (cb === true) {
            return soul(this, key, cb, as), this;
          }
          gun = this;
          var at = gun._, root = at.root, tmp = root.now, ev;
          as = cb || {};
          as.at = at;
          as.use = key;
          as.out = as.out || {};
          as.out.get = as.out.get || {};
          (ev = at.on("in", use, as)).rid = rid;
          (root.now = {$: 1})[as.now = at.id] = ev;
          var mum = root.mum;
          root.mum = {};
          at.on("out", as.out);
          root.mum = mum;
          root.now = tmp;
          return gun;
        } else if (num_is(key)) {
          return this.get("" + key, cb, as);
        } else if (tmp = rel.is(key)) {
          return this.get(tmp, cb, as);
        } else if (obj.is(key)) {
          gun = this;
          if (tmp = ((tmp = key["#"]) || empty)["="] || tmp) {
            gun = gun.get(tmp);
          }
          gun._.lex = key;
          return gun;
        } else {
          (as = this.chain())._.err = {err: Gun2.log("Invalid get request!", key)};
          if (cb) {
            cb.call(as, as._.err);
          }
          return as;
        }
        if (tmp = this._.stun) {
          gun._.stun = gun._.stun || tmp;
        }
        if (cb && typeof cb == "function") {
          gun.get(cb, as);
        }
        return gun;
      };
      function cache(key, back) {
        var cat = back._, next = cat.next, gun = back.chain(), at = gun._;
        if (!next) {
          next = cat.next = {};
        }
        next[at.get = key] = at;
        if (back === cat.root.$) {
          at.soul = key;
        } else if (cat.soul || cat.has) {
          at.has = key;
        }
        return at;
      }
      function soul(gun, cb, opt, as) {
        var cat = gun._, acks = 0, tmp;
        if (tmp = cat.soul || cat.link || cat.dub) {
          return cb(tmp, as, cat);
        }
        if (cat.jam) {
          return cat.jam.push([cb, as]);
        }
        cat.jam = [[cb, as]];
        gun.get(function go(msg, eve) {
          if (u === msg.put && !cat.root.opt.super && (tmp = Object.keys(cat.root.opt.peers).length) && ++acks <= tmp) {
            return;
          }
          eve.rid(msg);
          var at = (at = msg.$) && at._ || {}, i = 0, as2;
          tmp = cat.jam;
          delete cat.jam;
          while (as2 = tmp[i++]) {
            var cb2 = as2[0], id;
            as2 = as2[1];
            cb2 && cb2(id = at.link || at.soul || rel.is(msg.put) || node_soul(msg.put) || at.dub, as2, msg, eve);
          }
        }, {out: {get: {".": true}}});
        return gun;
      }
      function use(msg) {
        var eve = this, as = eve.as, cat = as.at, root = cat.root, gun = msg.$, at = (gun || {})._ || {}, data = msg.put || at.put, tmp;
        if ((tmp = root.now) && eve !== tmp[as.now]) {
          return eve.to.next(msg);
        }
        if (eve.seen && at.id && eve.seen[at.id]) {
          return eve.to.next(msg);
        }
        if ((tmp = data) && tmp[rel._] && (tmp = rel.is(tmp))) {
          tmp = (msg.$$ = at.root.$.get(tmp))._;
          if (u !== tmp.put) {
            msg = obj_to(msg, {put: data = tmp.put});
          }
        }
        if ((tmp = root.mum) && at.id) {
          var id = at.id + (eve.id || (eve.id = Gun2.text.random(9)));
          if (tmp[id]) {
            return;
          }
          if (u !== data && !rel.is(data)) {
            tmp[id] = true;
          }
        }
        as.use(msg, eve);
        if (eve.stun) {
          eve.stun = null;
          return;
        }
        eve.to.next(msg);
      }
      function rid(at) {
        var cat = this.on;
        if (!at || cat.soul || cat.has) {
          return this.off();
        }
        if (!(at = (at = (at = at.$ || at)._ || at).id)) {
          return;
        }
        var map = cat.map, tmp, seen;
        if (tmp = (seen = this.seen || (this.seen = {}))[at]) {
          return true;
        }
        seen[at] = true;
        return;
        return;
      }
      var obj = Gun2.obj, obj_map = obj.map, obj_has = obj.has, obj_to = Gun2.obj.to;
      var num_is = Gun2.num.is;
      var rel = Gun2.val.link, node_soul = Gun2.node.soul, node_ = Gun2.node._;
      var empty = {}, u;
    })(USE, "./get");
    ;
    USE(function(module2) {
      var Gun2 = USE("./root");
      Gun2.chain.put = function(data, cb, as) {
        var gun = this, at = gun._, root = at.root.$, ctx = root._, M = 100, tmp;
        as = as || {};
        as.data = data;
        as.via = as.$ = as.via || as.$ || gun;
        if (typeof cb === "string") {
          as.soul = cb;
        } else {
          as.ack = as.ack || cb;
        }
        if (at.soul) {
          as.soul = at.soul;
        }
        if (as.soul || root === gun) {
          if (!obj_is(as.data)) {
            (as.ack || noop).call(as, as.out = {err: Gun2.log("Data saved to the root level of the graph must be a node (an object), not a", typeof as.data, 'of "' + as.data + '"!')});
            if (as.res) {
              as.res();
            }
            return gun;
          }
          as.soul = as.soul || (as.not = Gun2.node.soul(as.data) || (as.via.back("opt.uuid") || Gun2.text.random)());
          as.via._.stun = {};
          if (!as.soul) {
            as.via.back("opt.uuid")(function(err2, soul2) {
              if (err2) {
                return Gun2.log(err2);
              }
              (as.ref || as.$).put(as.data, as.soul = soul2, as);
            });
            return gun;
          }
          as.$ = root.get(as.soul);
          as.ref = as.$;
          ify(as);
          return gun;
        }
        as.via._.stun = {};
        if (Gun2.is(data)) {
          data.get(function(soul2, o, msg) {
            if (!soul2) {
              delete as.via._.stun;
              return Gun2.log("The reference you are saving is a", typeof msg.put, '"' + msg.put + '", not a node (object)!');
            }
            gun.put(Gun2.val.link.ify(soul2), cb, as);
          }, true);
          return gun;
        }
        if (at.has && (tmp = Gun2.val.link.is(data))) {
          at.dub = tmp;
        }
        as.ref = as.ref || root._ === (tmp = at.back) ? gun : tmp.$;
        if (as.ref._.soul && Gun2.val.is(as.data) && at.get) {
          as.data = obj_put({}, at.get, as.data);
          as.ref.put(as.data, as.soul, as);
          return gun;
        }
        as.ref.get(any, true, {as});
        if (!as.out) {
          as.res = as.res || stun;
          as.$._.stun = as.ref._.stun;
        }
        return gun;
      };
      function ify(as) {
        as.batch = batch;
        var opt = as.opt || {}, env = as.env = Gun2.state.map(map, opt.state);
        env.soul = as.soul;
        as.graph = Gun2.graph.ify(as.data, env, as);
        if (env.err) {
          (as.ack || noop).call(as, as.out = {err: Gun2.log(env.err)});
          if (as.res) {
            as.res();
          }
          return;
        }
        as.batch();
      }
      function stun(cb) {
        if (cb) {
          cb();
        }
        return;
        var as = this;
        if (!as.ref) {
          return;
        }
        if (cb) {
          as.after = as.ref._.tag;
          as.now = as.ref._.tag = {};
          cb();
          return;
        }
        if (as.after) {
          as.ref._.tag = as.after;
        }
      }
      function batch() {
        var as = this;
        if (!as.graph || !obj_empty(as.stun)) {
          return;
        }
        as.res = as.res || function(cb) {
          if (cb) {
            cb();
          }
        };
        as.res(function() {
          delete as.via._.stun;
          var cat = as.$.back(-1)._, ask = cat.ask(function(ack) {
            cat.root.on("ack", ack);
            if (ack.err) {
              Gun2.log(ack);
            }
            if (++acks > (as.acks || 0)) {
              this.off();
            }
            if (!as.ack) {
              return;
            }
            as.ack(ack, this);
          }, as.opt), acks = 0;
          var tmp = cat.root.now;
          obj.del(cat.root, "now");
          var mum = cat.root.mum;
          cat.root.mum = {};
          as.ref._.on("out", {
            $: as.ref,
            put: as.out = as.env.graph,
            opt: as.opt,
            "#": ask
          });
          cat.root.mum = mum ? obj.to(mum, cat.root.mum) : mum;
          cat.root.now = tmp;
          as.via._.on("res", {});
          delete as.via._.tag.res;
        }, as);
        if (as.res) {
          as.res();
        }
      }
      function no(v, k) {
        if (v) {
          return true;
        }
      }
      function map(v, k, n, at) {
        var as = this;
        var is = Gun2.is(v);
        if (k || !at.path.length) {
          return;
        }
        (as.res || iife)(function() {
          var path = at.path, ref = as.ref, opt = as.opt;
          var i = 0, l = path.length;
          for (i; i < l; i++) {
            ref = ref.get(path[i]);
          }
          if (is) {
            ref = v;
          }
          var id = ref._.dub;
          if (id || (id = Gun2.node.soul(at.obj))) {
            ref.back(-1).get(id);
            at.soul(id);
            return;
          }
          (as.stun = as.stun || {})[path] = 1;
          ref.get(soul, true, {as: {at, as, p: path, ref}});
        }, {as, at});
      }
      var G = String.fromCharCode(31);
      function soul(id, as, msg, eve) {
        var as = as.as, path = as.p, ref = as.ref, cat = as.at, pat = [];
        as = as.as;
        ref.back(function(at2) {
          if (sat = at2.soul || at2.link || at2.dub) {
            return sat;
          }
          pat.push(at2.has || at2.get);
        });
        pat = [sat || as.soul].concat(pat.reverse());
        var at = ((msg || {}).$ || {})._ || {};
        id = at.dub = at.dub || id || Gun2.node.soul(cat.obj) || Gun2.node.soul(msg.put || at.put) || Gun2.val.link.is(msg.put || at.put) || pat.join("/");
        if (eve) {
          eve.stun = true;
        }
        if (!id) {
          as.via.back("opt.uuid")(function(err2, id2) {
            if (err2) {
              return Gun2.log(err2);
            }
            solve(at, at.dub = at.dub || id2, cat, as);
          });
          return;
        }
        solve(at, at.dub = id, cat, as);
      }
      function solve(at, id, cat, as) {
        at.$.back(-1).get(id);
        cat.soul(id);
        delete as.stun[cat.path];
        as.batch();
      }
      function any(soul2, as, msg, eve) {
        as = as.as;
        if (!msg.$ || !msg.$._) {
          return;
        }
        if (msg.err) {
          Gun2.log("Please report this as an issue! Put.any.err");
          return;
        }
        var at = msg.$._, data = at.put, opt = as.opt || {}, root, tmp;
        if ((tmp = as.ref) && tmp._.now) {
          return;
        }
        if (eve) {
          eve.stun = true;
        }
        if (as.ref !== as.$) {
          tmp = as.$._.get || at.get;
          if (!tmp) {
            delete as.via._.stun;
            Gun2.log("Please report this as an issue! Put.no.get");
            return;
          }
          as.data = obj_put({}, tmp, as.data);
          tmp = null;
        }
        if (u === data) {
          if (!at.get) {
            delete as.via._.stun;
            return;
          }
          if (!soul2) {
            tmp = at.$.back(function(at2) {
              if (at2.link || at2.soul) {
                return at2.link || at2.soul;
              }
              as.data = obj_put({}, at2.get, as.data);
            });
            as.not = true;
          }
          tmp = tmp || at.soul || at.link || at.dub;
          at = tmp ? at.root.$.get(tmp)._ : at;
          as.soul = tmp;
          data = as.data;
        }
        if (!as.not && !(as.soul = as.soul || soul2)) {
          if (as.path && obj_is(as.data)) {
            as.soul = (opt.uuid || as.via.back("opt.uuid") || Gun2.text.random)();
          } else {
            if (node_ == at.get) {
              as.soul = (at.put || empty)["#"] || at.dub;
            }
            as.soul = as.soul || at.soul || at.link || (opt.uuid || as.via.back("opt.uuid") || Gun2.text.random)();
          }
          if (!as.soul) {
            as.via.back("opt.uuid")(function(err2, soul3) {
              if (err2) {
                delete as.via._.stun;
                return Gun2.log(err2);
              }
              as.ref.put(as.data, as.soul = soul3, as);
            });
            return;
          }
        }
        as.ref.put(as.data, as.soul, as);
      }
      var obj = Gun2.obj, obj_is = obj.is, obj_put = obj.put, obj_map = obj.map, obj_empty = obj.empty;
      var u, empty = {}, noop = function() {
      }, iife = function(fn, as) {
        fn.call(as || empty);
      };
      var node_ = Gun2.node._;
    })(USE, "./put");
    ;
    USE(function(module2) {
      var Gun2 = USE("./root");
      USE("./chain");
      USE("./back");
      USE("./put");
      USE("./get");
      module2.exports = Gun2;
    })(USE, "./index");
    ;
    USE(function(module2) {
      var Gun2 = USE("./index");
      Gun2.chain.on = function(tag, arg, eas, as) {
        var gun = this, at = gun._, tmp, act, off;
        if (typeof tag === "string") {
          if (!arg) {
            return at.on(tag);
          }
          act = at.on(tag, arg, eas || at, as);
          if (eas && eas.$) {
            (eas.subs || (eas.subs = [])).push(act);
          }
          return gun;
        }
        var opt = arg;
        opt = opt === true ? {change: true} : opt || {};
        opt.at = at;
        opt.ok = tag;
        gun.get(ok, opt);
        return gun;
      };
      function ok(msg, ev) {
        var opt = this;
        var gun = msg.$, at = (gun || {})._ || {}, data = at.put || msg.put, cat = opt.at, tmp;
        if (u === data) {
          return;
        }
        if (tmp = msg.$$) {
          tmp = msg.$$._;
          if (u === tmp.put) {
            return;
          }
          data = tmp.put;
        }
        if (opt.change) {
          data = msg.put;
        }
        if (opt.as) {
          opt.ok.call(opt.as, msg, ev);
        } else {
          opt.ok.call(gun, data, msg.get, msg, ev);
        }
      }
      Gun2.chain.val = function(cb, opt) {
        Gun2.log.once("onceval", "Future Breaking API Change: .val -> .once, apologies unexpected.");
        return this.once(cb, opt);
      };
      Gun2.chain.once = function(cb, opt) {
        var gun = this, at = gun._, data = at.put;
        if (0 < at.ack && u !== data) {
          (cb || noop).call(gun, data, at.get);
          return gun;
        }
        if (cb) {
          (opt = opt || {}).ok = cb;
          opt.at = at;
          opt.out = {"#": Gun2.text.random(9)};
          gun.get(val, {as: opt});
          opt.async = true;
        } else {
          Gun2.log.once("valonce", "Chainable val is experimental, its behavior and API may change moving forward. Please play with it and report bugs and ideas on how to improve it.");
          var chain = gun.chain();
          chain._.nix = gun.once(function() {
            chain._.on("in", gun._);
          });
          return chain;
        }
        return gun;
      };
      function val(msg, eve, to) {
        if (!msg.$) {
          eve.off();
          return;
        }
        var opt = this.as, cat = opt.at, gun = msg.$, at = gun._, data = at.put || msg.put, link, tmp;
        if (tmp = msg.$$) {
          link = tmp = msg.$$._;
          if (u !== link.put) {
            data = link.put;
          }
        }
        if ((tmp = eve.wait) && (tmp = tmp[at.id])) {
          clearTimeout(tmp);
        }
        eve.ack = (eve.ack || 0) + 1;
        if (!to && u === data && !at.root.opt.super && eve.ack <= (opt.acks || Object.keys(at.root.opt.peers).length)) {
          return;
        }
        if (!to && (u === data || at.soul || at.link || link && !(0 < link.ack)) || u === data && !at.root.opt.super && (tmp = Object.keys(at.root.opt.peers).length) && (!to && (link || at).ack < tmp)) {
          tmp = (eve.wait = {})[at.id] = setTimeout(function() {
            val.call({as: opt}, msg, eve, tmp || 1);
          }, opt.wait || 99);
          return;
        }
        if (link && u === link.put && (tmp = rel.is(data))) {
          data = Gun2.node.ify({}, tmp);
        }
        eve.rid ? eve.rid(msg) : eve.off();
        opt.ok.call(gun || opt.$, data, msg.get);
      }
      Gun2.chain.off = function() {
        var gun = this, at = gun._, tmp;
        var cat = at.back;
        if (!cat) {
          return;
        }
        at.ack = 0;
        if (tmp = cat.next) {
          if (tmp[at.get]) {
            obj_del(tmp, at.get);
          } else {
          }
        }
        if (tmp = cat.ask) {
          obj_del(tmp, at.get);
        }
        if (tmp = cat.put) {
          obj_del(tmp, at.get);
        }
        if (tmp = at.soul) {
          obj_del(cat.root.graph, tmp);
        }
        if (tmp = at.map) {
          obj_map(tmp, function(at2) {
            if (at2.link) {
              cat.root.$.get(at2.link).off();
            }
          });
        }
        if (tmp = at.next) {
          obj_map(tmp, function(neat) {
            neat.$.off();
          });
        }
        at.on("off", {});
        return gun;
      };
      var obj = Gun2.obj, obj_map = obj.map, obj_has = obj.has, obj_del = obj.del, obj_to = obj.to;
      var rel = Gun2.val.link;
      var empty = {}, noop = function() {
      }, u;
    })(USE, "./on");
    ;
    USE(function(module2) {
      var Gun2 = USE("./index");
      Gun2.chain.map = function(cb, opt, t) {
        var gun = this, cat = gun._, chain;
        if (!cb) {
          if (chain = cat.each) {
            return chain;
          }
          cat.each = chain = gun.chain();
          chain._.nix = gun.back("nix");
          gun.on("in", map, chain._);
          return chain;
        }
        Gun2.log.once("mapfn", "Map functions are experimental, their behavior and API may change moving forward. Please play with it and report bugs and ideas on how to improve it.");
        chain = gun.chain();
        gun.map().on(function(data, key, at, ev) {
          var next = (cb || noop).call(this, data, key, at, ev);
          if (u === next) {
            return;
          }
          if (data === next) {
            return chain._.on("in", at);
          }
          if (Gun2.is(next)) {
            return chain._.on("in", next._);
          }
          chain._.on("in", {get: key, put: next});
        });
        return chain;
      };
      function map(msg) {
        if (!msg.put || Gun2.val.is(msg.put)) {
          return this.to.next(msg);
        }
        if (this.as.nix) {
          this.off();
        }
        obj_map(msg.put, each, {at: this.as, msg});
        this.to.next(msg);
      }
      function each(v, k) {
        if (n_ === k) {
          return;
        }
        var msg = this.msg, gun = msg.$, at = gun._, cat = this.at, tmp = at.lex;
        if (tmp && !Gun2.text.match(k, tmp["."] || tmp["#"] || tmp)) {
          return;
        }
        ((tmp = gun.get(k)._).echo || (tmp.echo = {}))[cat.id] = tmp.echo[cat.id] || cat;
      }
      var obj_map = Gun2.obj.map, noop = function() {
      }, event = {stun: noop, off: noop}, n_ = Gun2.node._, u;
    })(USE, "./map");
    ;
    USE(function(module2) {
      var Gun2 = USE("./index");
      Gun2.chain.set = function(item, cb, opt) {
        var gun = this, soul;
        cb = cb || function() {
        };
        opt = opt || {};
        opt.item = opt.item || item;
        if (soul = Gun2.node.soul(item)) {
          item = Gun2.obj.put({}, soul, Gun2.val.link.ify(soul));
        }
        if (!Gun2.is(item)) {
          if (Gun2.obj.is(item)) {
            soul = soul || Gun2.node.soul(item) || uuid();
          }
          return gun.get(soul || uuid()).put(item, cb, opt);
        }
        item.get(function(soul2, o, msg) {
          if (!soul2 && item._.stun) {
            item._.on("res", function() {
              this.off();
              gun.set(item, cb, opt);
            });
            return;
          }
          if (!soul2) {
            return cb.call(gun, {err: Gun2.log('Only a node can be linked! Not "' + msg.put + '"!')});
          }
          gun.put(Gun2.obj.put({}, soul2, Gun2.val.link.ify(soul2)), cb, opt);
        }, true);
        return item;
      };
      function uuid() {
        return Gun2.state.lex() + Gun2.text.random(7);
      }
    })(USE, "./set");
    ;
    USE(function(module2) {
      if (typeof Gun === "undefined") {
        return;
      }
      var root, noop = function() {
      }, store, u;
      try {
        store = (Gun.window || noop).localStorage;
      } catch (e) {
      }
      if (!store) {
        Gun.log("Warning: No localStorage exists to persist data to!");
        store = {setItem: function(k, v) {
          this[k] = v;
        }, removeItem: function(k) {
          delete this[k];
        }, getItem: function(k) {
          return this[k];
        }};
      }
      Gun.on("create", function(root2) {
        var ev = this.to, opt = root2.opt;
        if (root2.once) {
          return ev.next(root2);
        }
        if (opt.localStorage === false) {
          return ev.next(root2);
        }
        opt.prefix = opt.file || "gun/";
        var gap = Gun.obj.ify(store.getItem("gap/" + opt.prefix)) || {};
        var empty = Gun.obj.empty, id, to, go;
        if (!empty(gap)) {
          var disk = Gun.obj.ify(store.getItem(opt.prefix)) || {}, send = {};
          Gun.obj.map(gap, function(node, soul) {
            Gun.obj.map(node, function(val, key) {
              send[soul] = Gun.state.to(disk[soul], key, send[soul]);
            });
          });
          setTimeout(function() {
            root2.on("out", {put: send, "#": root2.ask(ack)});
          }, 1);
        }
        root2.on("out", function(msg) {
          if (msg.lS) {
            return;
          }
          if (Gun.is(msg.$) && msg.put && !msg["@"]) {
            id = msg["#"];
            Gun.graph.is(msg.put, null, map);
            if (!to) {
              to = setTimeout(flush, opt.wait || 1);
            }
          }
          this.to.next(msg);
        });
        root2.on("ack", ack);
        function ack(ack2) {
          if (ack2.err || !ack2.ok) {
            return;
          }
          var id2 = ack2["@"];
          setTimeout(function() {
            Gun.obj.map(gap, function(node, soul) {
              Gun.obj.map(node, function(val, key) {
                if (id2 !== val) {
                  return;
                }
                delete node[key];
              });
              if (empty(node)) {
                delete gap[soul];
              }
            });
            flush();
          }, opt.wait || 1);
        }
        ;
        ev.next(root2);
        var map = function(val, key, node, soul) {
          (gap[soul] || (gap[soul] = {}))[key] = id;
        };
        var flush = function() {
          clearTimeout(to);
          to = false;
          try {
            store.setItem("gap/" + opt.prefix, JSON.stringify(gap));
          } catch (e) {
            Gun.log(err = e || "localStorage failure");
          }
        };
      });
      Gun.on("create", function(root2) {
        this.to.next(root2);
        var opt = root2.opt;
        if (root2.once) {
          return;
        }
        if (opt.localStorage === false) {
          return;
        }
        opt.prefix = opt.file || "gun/";
        var graph = root2.graph, acks = {}, count = 0, to;
        var disk = Gun.obj.ify(store.getItem(opt.prefix)) || {};
        var lS = function() {
        }, u2;
        root2.on("localStorage", disk);
        root2.on("put", function(msg) {
          this.to.next(msg);
          var put = msg.put, soul = put["#"], key = put["."], val = put[":"], state = put[">"], tmp;
          disk[soul] = Gun.state.ify(disk[soul], key, state, val, soul);
          if (!msg["@"]) {
            (acks[msg["#"]] = tmp = (msg._ || "").lot || {}).lS = (tmp.lS || 0) + 1;
          }
          count += 1;
          if (count >= (opt.batch || 1e3)) {
            return flush();
          }
          if (to) {
            return;
          }
          to = setTimeout(flush, opt.wait || 1);
        });
        root2.on("get", function(msg) {
          this.to.next(msg);
          var lex = msg.get, soul, data, u3;
          function to2() {
            if (!lex || !(soul = lex["#"])) {
              return;
            }
            var has = lex["."];
            data = disk[soul] || u3;
            if (data && has) {
              data = Gun.state.to(data, has);
            }
            root2.on("in", {"@": msg["#"], put: Gun.graph.node(data), lS: 1});
          }
          ;
          Gun.debug ? setTimeout(to2, 1) : to2();
        });
        var map = function(val, key, node, soul) {
          disk[soul] = Gun.state.to(node, key, disk[soul]);
        };
        var flush = function(data) {
          var err2;
          count = 0;
          clearTimeout(to);
          to = false;
          var ack = acks;
          acks = {};
          if (data) {
            disk = data;
          }
          try {
            store.setItem(opt.prefix, JSON.stringify(disk));
          } catch (e) {
            Gun.log(err2 = (e || "localStorage failure") + " Consider using GUN's IndexedDB plugin for RAD for more storage space, https://gun.eco/docs/RAD#install");
            root2.on("localStorage:error", {err: err2, file: opt.prefix, flush: disk, retry: flush});
          }
          if (!err2 && !Gun.obj.empty(opt.peers)) {
            return;
          }
          Gun.obj.map(ack, function(yes, id) {
            if (yes) {
              if (yes.more) {
                acks[id] = yes;
                return;
              }
              if (yes.s !== yes.lS) {
                err2 = "localStorage batch not same.";
              }
            }
            root2.on("in", {
              "@": id,
              err: err2,
              ok: 0
            });
          });
        };
      });
    })(USE, "./adapters/localStorage");
    ;
    USE(function(module2) {
      var Type = USE("../type");
      function Mesh(root) {
        var mesh = function() {
        };
        var opt = root.opt || {};
        opt.log = opt.log || console.log;
        opt.gap = opt.gap || opt.wait || 0;
        opt.pack = opt.pack || (opt.memory ? opt.memory * 1e3 * 1e3 : 1399e6) * 0.3;
        opt.puff = opt.puff || 9;
        var puff = setTimeout.puff || setTimeout;
        var dup = root.dup, dup_check = dup.check, dup_track = dup.track;
        var hear = mesh.hear = function(raw, peer) {
          if (!raw) {
            return;
          }
          if (opt.pack <= raw.length) {
            return mesh.say({dam: "!", err: "Message too big!"}, peer);
          }
          var msg, id, hash, tmp = raw[0], DBG;
          if (mesh === this) {
            hear.d += raw.length || 0;
            ++hear.c;
          }
          if (tmp === "[") {
            try {
              msg = JSON.parse(raw);
            } catch (e) {
              opt.log("DAM JSON parse error", e);
            }
            raw = "";
            if (!msg) {
              return;
            }
            console.STAT && console.STAT(+new Date(), msg.length, "# on hear batch");
            var P = opt.puff;
            (function go() {
              var S2 = +new Date();
              var i = 0, m;
              while (i < P && (m = msg[i++])) {
                hear(m, peer);
              }
              msg = msg.slice(i);
              console.STAT && console.STAT(S2, +new Date() - S2, "hear loop");
              flush(peer);
              if (!msg.length) {
                return;
              }
              puff(go, 0);
            })();
            return;
          }
          if (tmp === "{" || (raw["#"] || obj_is(raw)) && (msg = raw)) {
            try {
              msg = msg || JSON.parse(raw);
            } catch (e) {
              return opt.log("DAM JSON parse error", e);
            }
            if (!msg) {
              return;
            }
            if (msg.DBG) {
              msg.DBG = DBG = {DBG: msg.DBG};
            }
            DBG && (DBG.hp = +new Date());
            if (!(id = msg["#"])) {
              id = msg["#"] = Type.text.random(9);
            }
            if (tmp = dup_check(id)) {
              return;
            }
            (msg._ = function() {
            }).via = mesh.leap = peer;
            if (tmp = msg.dam) {
              if (tmp = mesh.hear[tmp]) {
                tmp(msg, peer, root);
              }
              dup_track(id);
              return;
            }
            var S = +new Date(), ST;
            DBG && (DBG.is = S);
            root.on("in", msg);
            DBG && (DBG.hd = +new Date());
            console.STAT && (ST = +new Date() - S) > 9 && console.STAT(S, ST, "msg");
            dup_track(id).via = peer;
            mesh.leap = null;
          }
        };
        var tomap = function(k, i, m) {
          m(k, true);
        };
        var noop = function() {
        };
        hear.c = hear.d = 0;
        ;
        (function() {
          var SMIA = 0;
          var message, loop;
          function each(peer) {
            mesh.say(message, peer);
          }
          var say = mesh.say = function(msg, peer) {
            var tmp;
            if ((tmp = this) && (tmp = tmp.to) && tmp.next) {
              tmp.next(msg);
            }
            if (!msg) {
              return false;
            }
            var id, hash, raw;
            var DBG = msg.DBG, S;
            if (!peer) {
              S = +new Date();
              DBG && (DBG.y = S);
            }
            var meta = msg._ || (msg._ = function() {
            });
            if (!(id = msg["#"])) {
              id = msg["#"] = Type.text.random(9);
            }
            if (!(raw = meta.raw)) {
              raw = mesh.raw(msg);
            }
            S && console.STAT && console.STAT(S, +new Date() - S, "say prep");
            !loop && dup_track(id);
            if (!peer && (tmp = msg["@"])) {
              peer = (tmp = dup.s[tmp]) && (tmp.via || (tmp = tmp.it) && (tmp = tmp._) && tmp.via) || mesh.leap;
            }
            if (!peer && msg["@"]) {
              console.STAT && console.STAT(+new Date(), ++SMIA, "total no peer to ack to");
              return false;
            }
            if (!peer && mesh.way) {
              return mesh.way(msg);
            }
            if (!peer || !peer.id) {
              message = msg;
              if (!Type.obj.is(peer || opt.peers)) {
                return false;
              }
              var P = opt.puff, ps = opt.peers, pl = Object.keys(peer || opt.peers || {});
              ;
              (function go() {
                var S2 = +new Date();
                loop = 1;
                var wr = meta.raw;
                meta.raw = raw;
                var i = 0, p;
                while (i < 9 && (p = (pl || "")[i++])) {
                  if (!(p = ps[p])) {
                    continue;
                  }
                  say(msg, p);
                }
                meta.raw = wr;
                loop = 0;
                pl = pl.slice(i);
                console.STAT && console.STAT(S2, +new Date() - S2, "say loop");
                if (!pl.length) {
                  return;
                }
                puff(go, 0);
                dup_track(msg["@"]);
              })();
              return;
            }
            if (!peer.wire && mesh.wire) {
              mesh.wire(peer);
            }
            if (id === peer.last) {
              return;
            }
            peer.last = id;
            if (peer === meta.via) {
              return false;
            }
            if ((tmp = meta.to) && (tmp[peer.url] || tmp[peer.pid] || tmp[peer.id])) {
              return false;
            }
            if (peer.batch) {
              peer.tail = (tmp = peer.tail || 0) + raw.length;
              if (peer.tail <= opt.pack) {
                peer.batch += (tmp ? "," : "") + raw;
                return;
              }
              flush(peer);
            }
            peer.batch = "[";
            var S = +new Date(), ST;
            setTimeout(function() {
              console.STAT && (ST = +new Date() - S) > 9 && console.STAT(S, ST, "0ms TO", id, peer.id);
              flush(peer);
            }, opt.gap);
            send(raw, peer);
          };
          mesh.say.c = mesh.say.d = 0;
        })();
        function flush(peer) {
          var tmp = peer.batch, t = typeof tmp == "string", l;
          if (t) {
            tmp += "]";
          }
          peer.batch = peer.tail = null;
          if (!tmp) {
            return;
          }
          if (t ? 3 > tmp.length : !tmp.length) {
            return;
          }
          if (!t) {
            try {
              tmp = tmp.length === 1 ? tmp[0] : JSON.stringify(tmp);
            } catch (e) {
              return opt.log("DAM JSON stringify error", e);
            }
          }
          if (!tmp) {
            return;
          }
          send(tmp, peer);
        }
        function send(raw, peer) {
          try {
            var wire = peer.wire;
            if (peer.say) {
              peer.say(raw);
            } else if (wire.send) {
              wire.send(raw);
            }
            mesh.say.d += raw.length || 0;
            ++mesh.say.c;
          } catch (e) {
            (peer.queue = peer.queue || []).push(raw);
          }
        }
        ;
        (function() {
          mesh.raw = function(msg) {
            if (!msg) {
              return "";
            }
            var meta = msg._ || {}, put, hash, tmp;
            if (tmp = meta.raw) {
              return tmp;
            }
            if (typeof msg == "string") {
              return msg;
            }
            var raw = $(msg);
            if (meta && (raw || "").length < 1e3 * 100) {
              meta.raw = raw;
            }
            return raw;
          };
          var $ = JSON.stringify, _ = ":])([:";
        })();
        mesh.hi = function(peer) {
          var tmp = peer.wire || {};
          if (peer.id) {
            opt.peers[peer.url || peer.id] = peer;
          } else {
            tmp = peer.id = peer.id || Type.text.random(9);
            mesh.say({dam: "?", pid: root.opt.pid}, opt.peers[tmp] = peer);
            delete dup.s[peer.last];
          }
          peer.met = peer.met || +new Date();
          if (!tmp.hied) {
            root.on(tmp.hied = "hi", peer);
          }
          tmp = peer.queue;
          peer.queue = [];
          Type.obj.map(tmp, function(msg) {
            send(msg, peer);
          });
          Type.obj.native && Type.obj.native();
        };
        mesh.bye = function(peer) {
          root.on("bye", peer);
          var tmp = +new Date();
          tmp = tmp - (peer.met || tmp);
          mesh.bye.time = ((mesh.bye.time || tmp) + tmp) / 2;
        };
        mesh.hear["!"] = function(msg, peer) {
          opt.log("Error:", msg.err);
        };
        mesh.hear["?"] = function(msg, peer) {
          if (msg.pid) {
            if (!peer.pid) {
              peer.pid = msg.pid;
            }
            if (msg["@"]) {
              return;
            }
          }
          mesh.say({dam: "?", pid: opt.pid, "@": msg["#"]}, peer);
          delete dup.s[peer.last];
        };
        root.on("create", function(root2) {
          root2.opt.pid = root2.opt.pid || Type.text.random(9);
          this.to.next(root2);
          root2.on("out", mesh.say);
        });
        root.on("bye", function(peer, tmp) {
          peer = opt.peers[peer.id || peer] || peer;
          this.to.next(peer);
          peer.bye ? peer.bye() : (tmp = peer.wire) && tmp.close && tmp.close();
          Type.obj.del(opt.peers, peer.id);
          peer.wire = null;
        });
        var gets = {};
        root.on("bye", function(peer, tmp) {
          this.to.next(peer);
          if (!(tmp = peer.url)) {
            return;
          }
          gets[tmp] = true;
          setTimeout(function() {
            delete gets[tmp];
          }, opt.lack || 9e3);
        });
        root.on("hi", function(peer, tmp) {
          this.to.next(peer);
          if (!(tmp = peer.url) || !gets[tmp]) {
            return;
          }
          delete gets[tmp];
          if (opt.super) {
            return;
          }
          Type.obj.map(root.next, function(node, soul) {
            tmp = {};
            tmp[soul] = root.graph[soul];
            mesh.say({"##": Type.obj.hash(tmp), get: {"#": soul}}, peer);
          });
        });
        return mesh;
      }
      ;
      (function() {
        var $ = JSON.stringify, u2;
        Type.obj.hash = function(obj, hash) {
          if (!hash && u2 === (obj = $(obj, sort))) {
            return;
          }
          return Type.text.hash(hash || obj || "");
        };
        function sort(k, v) {
          var tmp;
          if (!(v instanceof Object)) {
            return v;
          }
          var S = +new Date();
          Type.obj.map(Object.keys(v).sort(), map, {to: tmp = {}, on: v});
          console.STAT && console.STAT(S, +new Date() - S, "sort");
          return tmp;
        }
        Type.obj.hash.sort = sort;
        function map(k) {
          this.to[k] = this.on[k];
        }
      })();
      function it(msg) {
        return msg || {_: msg._, "##": msg["##"]};
      }
      var empty = {}, ok = true, u;
      var obj_is = Type.obj.is, obj_map = Type.obj.map;
      try {
        module2.exports = Mesh;
      } catch (e) {
      }
    })(USE, "./adapters/mesh");
    ;
    USE(function(module2) {
      var Gun2 = USE("../index");
      Gun2.Mesh = USE("./mesh");
      Gun2.on("opt", function(root) {
        this.to.next(root);
        var opt = root.opt;
        if (root.once) {
          return;
        }
        if (opt.WebSocket === false) {
          return;
        }
        var env;
        if (typeof window !== "undefined") {
          env = window;
        }
        if (typeof global !== "undefined") {
          env = global;
        }
        env = env || {};
        var websocket = opt.WebSocket || env.WebSocket || env.webkitWebSocket || env.mozWebSocket;
        if (!websocket) {
          return;
        }
        opt.WebSocket = websocket;
        var mesh = opt.mesh = opt.mesh || Gun2.Mesh(root);
        var wire = mesh.wire || opt.wire;
        mesh.wire = opt.wire = open;
        function open(peer) {
          try {
            if (!peer || !peer.url) {
              return wire2 && wire2(peer);
            }
            var url = peer.url.replace(/^http/, "ws");
            var wire2 = peer.wire = new opt.WebSocket(url);
            wire2.onclose = function() {
              opt.mesh.bye(peer);
              reconnect(peer);
            };
            wire2.onerror = function(error) {
              reconnect(peer);
            };
            wire2.onopen = function() {
              opt.mesh.hi(peer);
            };
            wire2.onmessage = function(msg) {
              if (!msg) {
                return;
              }
              opt.mesh.hear(msg.data || msg, peer);
            };
            return wire2;
          } catch (e) {
          }
        }
        setTimeout(function() {
          root.on("out", {dam: "hi"});
        }, 1);
        var wait = 2 * 1e3;
        function reconnect(peer) {
          clearTimeout(peer.defer);
          if (doc && peer.retry <= 0) {
            return;
          }
          peer.retry = (peer.retry || opt.retry || 60) - 1;
          peer.defer = setTimeout(function to() {
            if (doc && doc.hidden) {
              return setTimeout(to, wait);
            }
            open(peer);
          }, wait);
        }
        var doc = typeof document !== "undefined" && document;
      });
      var noop = function() {
      };
    })(USE, "./adapters/websocket");
  })();
});

// dep:gun
var require_gun2 = __commonJS((exports, module) => {
  module.exports = require_gun();
});
export default require_gun2();
//# sourceMappingURL=gun.js.map
